---
- name: Join AlmaLinux 9 to AD Domain (ad.noxvfx.com)
  hosts: all
  become: yes
  vars:
    domain_name: "ad.noxvfx.com"
    domain_controller: "dc-1.ad.noxvfx.com"
    domain_admin_user: "noxadmin@AD.NOXVFX.COM"
    domain_realm: "AD.NOXVFX.COM"
    domain_admin_password: "{{ vault_domain_password | default('') }}"
    
    # NFS configuration
    nfs_server: "192.168.11.9"
    autofs_base_path: "/mnt"
    
    # Public mounts (all users)
    nfs_mounts_public:
      - { src: "/volume1/Projects", dest: "Projects" }
      - { src: "/volume1/Library", dest: "Library" }
    
    # Restricted mounts (NOX Admins only)
    nfs_mounts_noxadmins:
      - { src: "/volume1/Archive", dest: "Archive" }
      - { src: "/volume2/Expansion1", dest: "Expansion" }

  tasks:
    - name: Update all packages
      ansible.builtin.dnf:
        name: "*"
        state: latest
      register: system_update

    - name: Reboot if kernel was updated
      ansible.builtin.reboot:
        reboot_timeout: 300
      when: system_update.changed and 'kernel' in system_update.results | string

    - name: Install required packages for domain joining
      ansible.builtin.dnf:
        name:
          - realmd
          - sssd
          - oddjob
          - oddjob-mkhomedir
          - adcli
          - samba-common-tools
          - krb5-workstation
          - nfs-utils
          - autofs
          - xfsprogs
        state: present

    - name: Start and enable required services
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: started
        enabled: yes
      loop:
        - realmd
        - sssd
        - oddjobd

    - name: Check if system is already joined to domain
      ansible.builtin.command: realm list
      register: realm_status
      changed_when: false
      failed_when: false

    - name: Discover the domain
      ansible.builtin.command: "realm discover {{ domain_name }}"
      register: realm_discover
      when: domain_name not in realm_status.stdout

    - name: Display domain discovery results
      ansible.builtin.debug:
        var: realm_discover.stdout_lines
      when: realm_discover is defined

    - name: Prompt for domain admin password if not provided
      ansible.builtin.pause:
        prompt: "Enter password for {{ domain_admin_user }}"
        echo: no
      register: password_prompt
      when: 
        - domain_admin_password == ""
        - domain_name not in realm_status.stdout

    - name: Set domain password from prompt
      ansible.builtin.set_fact:
        domain_admin_password: "{{ password_prompt.user_input }}"
      when: password_prompt is defined and password_prompt.user_input is defined

    - name: Join the domain
      ansible.builtin.expect:
        command: "realm join -U {{ domain_admin_user }} {{ domain_controller }} -v"
        responses:
          Password for *: "{{ domain_admin_password }}"
        timeout: 60
      register: domain_join_result
      when: domain_name not in realm_status.stdout

    - name: Display domain join results
      ansible.builtin.debug:
        var: domain_join_result
      when: domain_join_result is defined

    - name: Configure SSSD
      ansible.builtin.copy:
        content: |
          [sssd]
          domains = {{ domain_name }}
          config_file_version = 2
          services = nss, pam

          [domain/{{ domain_name }}]
          default_shell = /bin/bash
          ad_server = {{ domain_controller }}
          krb5_store_password_if_offline = True
          cache_credentials = True
          krb5_realm = {{ domain_realm }}
          realmd_tags = manages-system joined-with-adcli
          id_provider = ad
          fallback_homedir = /home/%d/%u
          ad_domain = {{ domain_name }}
          use_fully_qualified_names = False
          ldap_id_mapping = True
          access_provider = ad
        dest: /etc/sssd/sssd.conf
        mode: '0600'
        owner: root
        group: root
        backup: yes
      notify: restart sssd

    - name: Add domain groups to sudoers
      ansible.builtin.lineinfile:
        path: /etc/sudoers
        line: "{{ item }}"
        state: present
        validate: 'visudo -cf %s'
        backup: yes
      loop:
        - "%domain\\ admins ALL=(ALL:ALL) ALL"
        - "%nox-admins ALL=(ALL:ALL) ALL"

    - name: Configure idmapd.conf for NFS
      ansible.builtin.lineinfile:
        path: /etc/idmapd.conf
        regexp: '^#?Domain\s*='
        line: "Domain = {{ domain_name }}"
        backup: yes

    # Cache disk detection and mounting
    - name: Find cache disk by label
      ansible.builtin.command: blkid -L Cache
      register: cache_disk_labeled
      failed_when: false
      changed_when: false

    - name: If no labeled cache disk, find unformatted ~1TB disk
      block:
        - name: Get all block devices
          ansible.builtin.command: lsblk -ndo NAME,SIZE,TYPE,FSTYPE -b
          register: all_disks
          changed_when: false

        - name: Find unformatted disks between 900GB and 1100GB
          ansible.builtin.shell: |
            lsblk -ndo NAME,SIZE,TYPE,FSTYPE -b | \
            awk '$3=="disk" && $4=="" && $2>=900000000000 && $2<=1100000000000 {print $1}'
          register: potential_cache_disks_raw
          changed_when: false

        - name: Set potential cache disks fact
          ansible.builtin.set_fact:
            potential_cache_disks: "{{ potential_cache_disks_raw.stdout_lines }}"
          when: potential_cache_disks_raw.stdout_lines | length > 0

        - name: Display potential cache disks
          ansible.builtin.debug:
            msg: "Found potential unformatted cache disk(s): {{ potential_cache_disks }}"
          when: potential_cache_disks is defined and potential_cache_disks | length > 0

        - name: Prompt for confirmation to format disk
          ansible.builtin.pause:
            prompt: |
              Host: {{ inventory_hostname }}
              Found unformatted disk(s) around 1TB: {{ potential_cache_disks | join(', ') }}
              
              Do you want to format /dev/{{ potential_cache_disks[0] }} as Cache? (yes/no)
          register: format_confirmation
          when: potential_cache_disks is defined and potential_cache_disks | length > 0

        - name: Set cache device to format
          ansible.builtin.set_fact:
            cache_device: "/dev/{{ potential_cache_disks[0] }}"
          when: 
            - potential_cache_disks is defined
            - potential_cache_disks | length > 0
            - format_confirmation is defined
            - format_confirmation.user_input is defined
            - format_confirmation.user_input | lower == 'yes'

        - name: Check if cache device is mounted
          ansible.builtin.shell: "mount | grep {{ cache_device }}"
          register: device_mounted
          failed_when: false
          changed_when: false
          when: cache_device is defined

        - name: Unmount cache device if mounted
          ansible.builtin.command: "umount {{ cache_device }}"
          when: 
            - cache_device is defined
            - device_mounted is defined
            - device_mounted.rc == 0
          register: unmount_result
          failed_when: unmount_result.rc != 0 and 'not mounted' not in unmount_result.stderr

        - name: Format disk as XFS with label Cache
          ansible.builtin.filesystem:
            fstype: xfs
            dev: "{{ cache_device }}"
            opts: -L Cache
            force: yes
          when: cache_device is defined

        - name: Update cache_disk variable after formatting
          ansible.builtin.command: blkid -L Cache
          register: cache_disk_labeled
          changed_when: false
          when: cache_device is defined

      when: cache_disk_labeled.rc != 0

    - name: Set cache disk path
      ansible.builtin.set_fact:
        cache_disk_path: "{{ cache_disk_labeled.stdout }}"
      when: 
        - cache_disk_labeled is defined
        - cache_disk_labeled.rc is defined
        - cache_disk_labeled.rc == 0

    - name: Display cache disk found
      ansible.builtin.debug:
        msg: "Cache disk found: {{ cache_disk_path }}"
      when: cache_disk_path is defined

    - name: Create /mnt/Cache directory
      ansible.builtin.file:
        path: /mnt/Cache
        state: directory
        mode: '0755'
      when: cache_disk_path is defined

    - name: Get UUID of cache disk
      ansible.builtin.command: "blkid -s UUID -o value {{ cache_disk_path }}"
      register: cache_uuid
      changed_when: false
      when: cache_disk_path is defined

    - name: Add cache disk to fstab using UUID
      ansible.builtin.mount:
        path: /mnt/Cache
        src: "UUID={{ cache_uuid.stdout }}"
        fstype: xfs
        opts: defaults,noatime
        state: present
        backup: yes
      when: cache_disk_path is defined and cache_uuid.stdout != ""

    - name: Mount cache disk
      ansible.builtin.mount:
        path: /mnt/Cache
        src: "UUID={{ cache_uuid.stdout }}"
        fstype: xfs
        opts: defaults,noatime
        state: mounted
      when: cache_disk_path is defined and cache_uuid.stdout != ""
      register: cache_mount_result

    - name: Display cache mount result
      ansible.builtin.debug:
        msg: "Cache disk mounted successfully at /mnt/Cache"
      when: cache_mount_result is defined and cache_mount_result is succeeded

    # Autofs configuration for per-user NFS mounts
    - name: Configure autofs master map
      ansible.builtin.lineinfile:
        path: /etc/auto.master
        line: "/mnt /etc/auto.nfs --timeout=60"
        state: present
        backup: yes
      notify: restart autofs

    - name: Create autofs NFS map file for public mounts
      ansible.builtin.copy:
        content: |
          # Public mounts (all users)
          {% for mount in nfs_mounts_public %}
          {{ mount.dest }} -fstype=nfs,rw {{ nfs_server }}:{{ mount.src }}
          {% endfor %}
        dest: /etc/auto.nfs
        mode: '0644'
        backup: yes
      notify: restart autofs

    - name: Start and enable autofs service
      ansible.builtin.systemd:
        name: autofs
        state: started
        enabled: yes

    - name: Create PAM script directory
      ansible.builtin.file:
        path: /usr/share/libpam-script
        state: directory
        mode: '0755'

    - name: Create script to add NFS bookmarks to GNOME Files
      ansible.builtin.copy:
        content: |
          #!/bin/bash
          # This script adds NFS mounts as bookmarks in GNOME Files
          
          USER_HOME=$(eval echo ~$PAM_USER)
          BOOKMARKS_FILE="$USER_HOME/.config/gtk-3.0/bookmarks"
          
          # Create gtk-3.0 config directory if it doesn't exist
          mkdir -p "$USER_HOME/.config/gtk-3.0"
          
          # Add public mounts bookmarks for all users
          {% for mount in nfs_mounts_public %}
          BOOKMARK="file://{{ autofs_base_path }}/{{ mount.dest }} {{ mount.dest }}"
          if ! grep -Fxq "$BOOKMARK" "$BOOKMARKS_FILE" 2>/dev/null; then
              echo "$BOOKMARK" >> "$BOOKMARKS_FILE"
          fi
          {% endfor %}
          
          # Add NOX Admins bookmarks if user is member of the group
          if id -nG "$PAM_USER" | grep -qw "nox-admins"; then
              {% for mount in nfs_mounts_noxadmins %}
              BOOKMARK="file://{{ autofs_base_path }}/{{ mount.dest }} {{ mount.dest }}"
              if ! grep -Fxq "$BOOKMARK" "$BOOKMARKS_FILE" 2>/dev/null; then
                  echo "$BOOKMARK" >> "$BOOKMARKS_FILE"
              fi
              {% endfor %}
          fi
          
          # Set correct ownership - use UID instead of group name to avoid space issues
          USER_UID=$(id -u "$PAM_USER")
          USER_GID=$(id -g "$PAM_USER")
          chown "$USER_UID:$USER_GID" "$BOOKMARKS_FILE"
          chmod 644 "$BOOKMARKS_FILE"
          
          exit 0
        dest: /usr/share/libpam-script/pam_script_bookmarks.sh
        mode: '0755'
        backup: yes

    - name: Create PAM session script for NOX Admins mounts and bookmarks
      ansible.builtin.copy:
        content: |
          #!/bin/bash
          # This script runs when a user logs in
          
          # Check if user is member of "nox-admins" group (as seen by Linux)
          if id -nG "$PAM_USER" | grep -qw "nox-admins"; then
              # Create NOX Admins autofs map if it doesn't exist
              if [ ! -f /etc/auto.nfs.noxadmins ]; then
                  cat > /etc/auto.nfs.noxadmins << 'EOF'
          {% for mount in nfs_mounts_noxadmins %}
          {{ mount.dest }} -fstype=nfs,rw {{ nfs_server }}:{{ mount.src }}
          {% endfor %}
          EOF
              fi
              
              # Add NOX Admins mounts to auto.nfs if not present
              {% for mount in nfs_mounts_noxadmins %}
              if ! grep -q "^{{ mount.dest }}" /etc/auto.nfs; then
                  echo "{{ mount.dest }} -fstype=nfs,rw {{ nfs_server }}:{{ mount.src }}" >> /etc/auto.nfs
              fi
              {% endfor %}
              
              # Reload autofs
              systemctl reload autofs
          fi
          
          # Add bookmarks to GNOME Files
          /usr/share/libpam-script/pam_script_bookmarks.sh
          
          exit 0
        dest: /usr/share/libpam-script/pam_script_ses_open
        mode: '0755'
        backup: yes

    - name: Configure PAM to use the script
      ansible.builtin.lineinfile:
        path: /etc/pam.d/system-auth
        line: "session optional pam_exec.so /usr/share/libpam-script/pam_script_ses_open"
        insertafter: "^session.*pam_systemd"
        state: present
        backup: yes

    - name: Test NFS connectivity before mounting
      ansible.builtin.command: "showmount -e {{ nfs_server }}"
      register: nfs_exports
      failed_when: false
      changed_when: false

    - name: Display NFS exports
      ansible.builtin.debug:
        msg: "Available NFS exports: {{ nfs_exports.stdout_lines }}"
      when: nfs_exports.rc == 0

    - name: Verify domain join status
      ansible.builtin.command: realm list
      register: final_realm_status
      changed_when: false

    - name: Display final domain status
      ansible.builtin.debug:
        msg: "Domain join status: {{ 'SUCCESS' if domain_name in final_realm_status.stdout else 'FAILED' }}"

    - name: Test domain user authentication (optional)
      ansible.builtin.command: "id {{ domain_admin_user.split('@')[0] }}"
      register: user_test
      failed_when: false
      changed_when: false

    - name: Reboot system to complete domain join
      ansible.builtin.reboot:
        reboot_timeout: 300
        msg: "Rebooting to complete domain join process"
      when: domain_join_result is defined and domain_join_result.changed

  handlers:
    - name: restart sssd
      ansible.builtin.systemd:
        name: sssd
        state: restarted
        daemon_reload: yes

    - name: restart autofs
      ansible.builtin.systemd:
        name: autofs
        state: restarted
